Pointer Semantics
Changes in Go 1.6
26 Oct 2015
Tags: edmonton-go, golang, go1.6

Matthias Stone
CTO, Bellstone Engineering
matthias@bellstone.ca
@MatthiasStone
+MatthiasStone




* What is cgo?

- cgo lets Go packages call C code
- As of Go 1.5 C code can now call Go

* Example

.code pointers1.6/rand.go
.caption Cgo does not work in the playground!
.caption Cgo is very dangerous!

* What is a Pointer

# Ask if we can skip this.

.image pointers1.6/Pointers.svg.png
.caption en.wikipedia.org/wiki/Pointer_(computer_programming)

* Pointer in C

* Dangers

* New semantics

The major change is the definition of rules for sharing Go pointers with C code, to ensure that such C code can coexist with Go's garbage collector. Briefly, Go and C may share memory allocated by Go when a pointer to that memory is passed to C as part of a cgo call, provided that the memory itself contains no pointers to Go-allocated memory, and provided that C does not retain the pointer after the call returns. These rules are checked by the runtime during program execution: if the runtime detects a violation, it prints a diagnosis and crashes the program. The checks can be disabled by setting the environment variable GODEBUG=cgocheck=0, but note that the vast majority of code identified by the checks is subtly incompatible with garbage collection in one way or another. Disabling the checks will typically only lead to more mysterious failure modes. Fixing the code in question should be strongly preferred over turning off the checks. See the cgo documentation for more details.

* Questions?

# C.complexfloat, C.complexdouble != complex64, complex128

* Bellstone Engineering is Hiring!
